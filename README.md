# penguin-tools

A set of ad-hoc scripts and jupyter notebooks to analyse penguin genomic data. For each tool, see `--help` for the detail of arguments.

`gff2fasta.py` extracts all coding sequences from a reference fasta file, based on gff annotations. It will concatenate the CDS together, adjusting the phasing and strand direction as needed. It can also output the amino-acid sequence with `--type AA`.

`polariseVCF.py` replaces the REF and ALT bases in a VCF file by the ancestral and derived bases, taken from an ancestral reconstruction of the same genome (which needs to share the same coordinates - typically a `baseml`reconstruction. All the matching infromation (genotypes, likelihoods...) follow.

`updateFasta.py` updates a reference genome to include the variants discovered in a specific population. It can replace the reference base with the IUPAC ambiguity code, or the reference / alternative / major / minor allele. If an ancestral reconstruction is provided, ambiguities in the reference genome will be set to the ancestral base, so that only the polymorphism actually present in the variant population will be represented in the final sequence. If the ancestral base is itself ambiguous or undefined, ambiguities are masked.

`markovMask.py` identifies regions of a genome that appear misassembled based on sequencing depth of a panel of individuals. The rationale is that summed sequencing depth for a panel of individuals is expected to follow a negative binomial distribution, and that regions that deviate from this expectation are likely to be collapsed paralogs (over-sequenced) or highly repetitive, hard-to-align DNA (under-sequenced). We fit a negative binomial distribution to the center of the distribution based on quantile-quantile least square regression, and two generic "flanking" negative binomials to account for high and low coverage areas. We then use a hidden Markov model to identify state changes in the assembly. Finally, outside of outlier blocks, we remove individual sites that seem under- or over-sequenced. The result is a BED file with regions identified as problematic, and a sites file listing sites that pass filters.

`make_feature_map.py` combines information from a GFF file, a CpG cluster annotation file produced in gCluster, and a VCF reference SNP file, into a binary file called feature.map, in which each site is represented by 1 byte, with the following code (in powers of 2): `{'cpg':0, 'cpgi':1, 'cisreg':2, 'intron':3, 'exon':4, 'ct_snp':5}`. This map is fused to a methylation matrix (without missing values, i.e. filled in at missing sites with bsbolt's imputation function), into a binary matrix with the full position in the genome (int), followed by one byte representing the site's classification, followed by floats (4 bytes*nIndividuals). This matrix can be used to query rapidly methylation levels from an arbitrary combination of features. At that stage, the counts of methylated Cs and total Cs in the input matrix are summarized for both bases in the CpG site into a single ratio (with a 9.999999 float indicating a missing value). That matrix can be used for plotting, querying, subsetting, etc. It can be dumped quickly to text format with the `dump_methylation_matrix` program (usage: `dump_methylation_matrix filepath n_samples`).

`fuse_cpg_sites.py` combines information about the plus- and minus-strand sequencing data at CpG sites, and outputs a consolidated file with only one site per CpG (the plus-strand C site). This works with both bsbolt and bismark output files.

`get_depth_quantiles` (source, or exe in bin folder) is a small program to extract deth of coverage quantiles from vcftools' --site-mean-depth option, in order to assist filtering decisions. It can test a given pair of quantiles (`-l` and `-u` options for lower and upper levels) or, with the `-a` option, automatically output a set of standard levels. Sepcify infput file path with the `-i` flag.
